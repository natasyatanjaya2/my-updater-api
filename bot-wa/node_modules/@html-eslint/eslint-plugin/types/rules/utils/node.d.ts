/**
 * @param {Tag | ScriptTag | StyleTag} node
 * @param {string} key
 * @returns {Attribute | undefined}
 */
export function findAttr(node: Tag | ScriptTag | StyleTag, key: string): Attribute | undefined;
/**
 * Checks whether a node's attributes is empty or not.
 * @param {Tag | ScriptTag | StyleTag} node
 * @returns {boolean}
 */
export function isAttributesEmpty(node: Tag | ScriptTag | StyleTag): boolean;
/**
 * Checks whether a node's all tokens are on the same line or not.
 * @param {AnyNode} node A node to check
 * @returns {boolean} `true` if a node's tokens are on the same line, otherwise `false`.
 */
export function isNodeTokensOnSameLine(node: AnyNode): boolean;
/**
 *
 * @param {Text | CommentContent} node
 * @returns {Line[]}
 */
export function splitToLineNodes(node: Text | CommentContent): Line[];
/**
 * Get location between two nodes.
 * @param {{loc: AST.SourceLocation}} before A node placed in before
 * @param {{loc: AST.SourceLocation}} after A node placed in after
 * @returns {AST.SourceLocation} location between two nodes.
 */
export function getLocBetween(before: {
    loc: AST.SourceLocation;
}, after: {
    loc: AST.SourceLocation;
}): AST.SourceLocation;
/**
 * @param {AnyNode} node
 * @param {(node: AnyNode) => boolean} predicate
 * @returns {null | AnyNode}
 */
export function findParent(node: AnyNode, predicate: (node: AnyNode) => boolean): null | AnyNode;
/**
 * @param {BaseNode} node
 * @returns {node is Tag}
 */
export function isTag(node: BaseNode): node is Tag;
/**
 * @param {BaseNode} node
 * @returns {node is Comment}
 */
export function isComment(node: BaseNode): node is Comment;
/**
 * @param {BaseNode} node
 * @returns {node is Text}
 */
export function isText(node: BaseNode): node is Text;
/**
 * @param {BaseNode} node
 * @returns {node is Line}
 */
export function isLine(node: BaseNode): node is Line;
/**
 * @param {BaseNode} node
 * @returns {node is ScriptTag}
 */
export function isScript(node: BaseNode): node is ScriptTag;
/**
 * @param {BaseNode} node
 * @returns {node is StyleTag}
 */
export function isStyle(node: BaseNode): node is StyleTag;
/**
 * @param {(Text | CommentContent)['parts']} parts
 * @param {AST.Range} range
 * @returns {boolean}
 */
export function isOverlapWithTemplates(parts: (Text | CommentContent)["parts"], range: AST.Range): boolean;
/**
 * @param {string} source
 * @returns {string[]}
 */
export function codeToLines(source: string): string[];
/**
 *
 * @param {AST.Range} rangeA
 * @param {AST.Range} rangeB
 * @returns {boolean}
 */
export function isRangesOverlap(rangeA: AST.Range, rangeB: AST.Range): boolean;
/**
 *
 * @param {AnyToken[]} tokens
 * @returns {((CommentContent | Text)['parts'][number])[]}
 */
export function getTemplateTokens(tokens: AnyToken[]): ((CommentContent | Text)["parts"][number])[];
/**
 * @param {AttributeKey | AttributeValue | Text | CommentContent} node
 * @returns {boolean}
 */
export function hasTemplate(node: AttributeKey | AttributeValue | Text | CommentContent): boolean;
/**
 * @param {Tag | ScriptTag} node
 * @param {string} attrName
 * @returns {boolean}
 */
export function hasAttr(node: Tag | ScriptTag, attrName: string): boolean;
import type { Tag } from "@html-eslint/types";
import type { ScriptTag } from "@html-eslint/types";
import type { StyleTag } from "@html-eslint/types";
import type { Attribute } from "@html-eslint/types";
import type { AnyNode } from "@html-eslint/types";
import type { Text } from "@html-eslint/types";
import type { CommentContent } from "@html-eslint/types";
import type { Line } from "../../types";
import type { AST } from "eslint";
import type { BaseNode } from "../../types";
import type { Comment } from "@html-eslint/types";
import type { AnyToken } from "@html-eslint/types";
import type { AttributeKey } from "@html-eslint/types";
import type { AttributeValue } from "@html-eslint/types";
//# sourceMappingURL=node.d.ts.map